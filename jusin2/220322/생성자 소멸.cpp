#include "pch.h"

class CStudent
{
public:
    int a;
public:
    CStudent()     // 생성자   생성자도 함수이다!
    {
        cout << "생성자 호출" << endl;
        a = 1;
    }
    CStudent(int _a)     // 생성자   생성자도 함수이다!
    {
        cout << "생성자 호출" << endl;
        //a = _a;
    }

    ~CStudent()     // 소멸자
    {

    }
};

int main()
{
    int* sp = new int[10];


    // 막 동적할당한 클래스의 힙공간은 쓰래기 값으로 채워진다.


    // 나는 선언과 동시에 초기화를 하고 싶다!
    // 생성자!!
    // 객체가 생성되는 시점에 반드시 실행되는 함수이다!

        // ******중요!!!! 암기!!!
    // 객체가 생성될 때 내부적으로 자동생성되는 네 가지
    // default 생성자, default 복사 생성자, default 대입 연산자, 소멸자

    // default 생성자는 프로그래머가 직접적으로 구현한 생성자가 단 한 개라도 있다면 사라진다.
    
        // ******중요!!!! 암기!!!
    // 객체의 생성과정 
    // 1. 메모리 할당 -> 생성자 호출

    // 즉, 생성자에서 초기화를 한다.
    // 엄연히 말하면 대입이지만, 객체가 생성되야 멤버변수, 함수의 접근 유효성이 생기는데,
    // 생성전에 대입이 이뤄지니 초기화가 이뤄진다고 할 수 있다.
    
    // 함수이니 오버로딩이 가능하다! >> 즉, 생성자가 여러개 존재 가능!


    // 객체의 조건은 메모리 할당, 생성자 호출을 해야 객체이다1!!!!!

    // 클래스 포인터를 malloc, calloc 동적할당을 하면 생성자가 호출 x
    // 클래스를 만들 때는 new delete!!!!
    //   ㄴ즉, 생성자 호출 안 하니깐 이건 객체가 아니다 




    // 소멸자
    // delete가 메모리를 해제할 때 호출되는 함수이다. (new는 생성자 호출)
    // free는 객체의 소멸자를 호출할 수 없다!!!!

        // ******중요!!!! 암기!!!
    // 객체의 소멸과정
    // 1.소멸자 호출   2. 메모리 반환

    // 소멸자를 구현하지 않으면 default 삽입
    // 소멸자는 오버로딩 불가능! 


    // 그렇다면 init release같은 함수는 필요없나
    // 디버깅 이유
    // 원할 때 해제, 원할 때 상태 갱신등 필요


    // 생성자와 소멸자는 반드시 구현한 상태에서 구현한다.
 
}

