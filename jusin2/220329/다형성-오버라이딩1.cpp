#include "pch.h"

// 다형성의 두 가지 방법
// 오버라이딩, 캐스팅!!


#pragma region 오버라이딩

// 1.오버라이딩
//	클래스가 상속관계에 있을 때 부모타입에서 자식타입의 멤버를 호출하는 문법

// 상속의 진정한 목적은? 
//  공통적인 자료형(정체성) 타입으로 묶어서 간단히 관리하겠다 >> 부모 포인터로 관리
// ex)
//  충돌 처리 -> (플레이어 직업 3) x (몬스터 3) = 9개의 충돌 함수를 만들어야함
//  즉, 개별적으로 만들기에는 코드양이 감당이 안됨.
//  부모 자료형으로 충돌처리를 하는 함수 하나만 만든다.

//  하지만 부모 자료형 포인터로는 자식의 멤버에 접근할 수 없다.
//  오버라이딩해서 이것을 가능하게 한다. >> virtual !!!!

#pragma endregion


#pragma region virtual 가상함수

#pragma endregion
// 일반적인 멤버함수 호출과 다르다

// 가상 함수를 하나 이상 가지는 클래스에 기본적으로 생기는 것들  (그림 첨부)
// 1.가상함수 포인터, 2.가상함수 테이블
//	- 가상함수 포인터 : 자신의 가상 테이블을 참조하고 있는 포인터
//	- 가상함수 테이블(목록): 가상 함수들만 따로 올라오는 곳 >> 코드 영역에 컴파일때 생성!
// 가상함수 포인터를 통해서 가상함수 테이블을 접근할 수 있다.
// 테이블은 함수 주소만 가지고 있는 개념이다 >> 테이블을 참조하는 추가적인 일 >> 일반 멤버함수 호출 보다 느리다
// 반환 이름 인자 전부 같다면 자식에도 virtual가 붙는다
// 즉, 자식의 함수도 virtual가 되어 자신의 테이블(포인터도)이 새로 만들어진다.

// 즉, 포인터를 부모로 해도 가상 포인터를 참조하면 자식의 테이블 참조하게 된다 >> 자식의 멤버 함수
// 즉, 호출하는 포인터가 어떤 주소를 가지고 있느냐에 따라 호출 함수를 정한다!!!! >> 런타임에!!!!!
//		ㄴ동적인 타이밍에(주소로) 참조할 함수 결정


// 정적(컴파일)은 빠르지만 바로 접근 범위가 결정이 난다.
// 동적(런타임)은 느리지만 런타임에서 프로그래머가 접근 범위를 결정할 수 있다.



// 동적 바인딩, 오버라이딩, 가상함수 작동원리 >> 3가지는 함께가는 개념이다.

// 오버라이딩을 하면 두 가지 특성을 가진다.
//	1.은닉화 >> 가상테이블이 어떤 클래스에 권한이 가느냐
//		ㄴ가상 테이블 자체는 컴파일(정적)에 할당. 실제 객체에 따라 호출되는 함수가 달라진다.
//	2.재정의
//		ㄴvirtual을 붙이면 자기의 멤버함수를 불러도 정적 바인딩으로 호출할 수 없다.
//        ㄴvirtual을 붙이면 무조건 가상 함수 포인터를 통해 함수를 접근한다.


class CObj
{
private:

public:
	virtual void Print()
	{

	}
};

class CPlayer : public CObj
{
private:

public:
	void Print()
	{

	}
};

int main()
{
	
}
