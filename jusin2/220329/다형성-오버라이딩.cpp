#include "pch.h"
// 다형성의 두 가지 방법
// 1. 오버라이딩
//	클래스가 상속관계에 있을 때 부모타입에서 자식타입의 멤버를 호출하는 문법
//	상속의 목적: 공통적인 자료형(정체성) 타입으로 묶어서 관리하겠다 >> 부모 포인터로 관리
// ex)
//  충돌 처리 -> (플레이어 직업 3) x (몬스터 3) = 9개의 충돌 함수를 만들어야함
//  즉, 개별적으로 만들기에는 코드양이 감당이 안됨.
//  부모 자료형으로 충돌처리를 하는 함수 하나만 만든다.

//  하지만 부모 자료형 포인터로는 자식의 멤버에 접근할 수 없다.
//  오버라이딩해서 이것을 가능하게 한다. >> virtual

// virtual     // 가상 함수
// 일반적인 멤버함수 호출과 다르다

// 가상 함수를 하나 이상 가지는 클래스에 기본적으로 생기는 것들
// 1 가상함수 포인터, 2 가상함수 테이블
//	- 가상함수 포인터: 코드영역에 생성?
//	- 가상함수 테이블(목록): 가상함수들만 따로 올라오는 곳
// 가상함수 포인터를 통해서 가상함수 테이블을 접근할 수 있다.
// 테이블은 함수 주소만 가지고 있는 개념이다 >> 테이블을 참조하는 추가적인 일 >> 일반 멤버함수 호출 보다 느리다
// 반환 이름 인자 전부 같다면 자식에도 virtual가 붙는다
// 즉, 자식의 함수도 virtual가 되어 테이블(포인터도)이 새로 만들어진다.

// 즉, 포인터를 부모로 해도 가상 포인터를 참조하면 자식의 테이블 참조하게 된다 >> 자식의 멤버 함수
// 즉, 호출하는 포인터가 어떤 주소를 가지고 있느냐에 따라 호출 함수를 정한다!!!! >> 런타임에!!!!!
// 동적인 타이밍에(주소로) 참조할 함수 결정
// 정적(컴파일)은 빠르지만 바로 접근 범위가 결정이 난다.
// 동적(런타임)은 느리지만 런타임에서 프로그래머가 접근 범위를 결정할 수 있다.

class CObj
{
private:

public:
	virtual void Print()
	{

	}
};

class CPlayer : public CObj
{
private:

public:
	void Print()
	{

	}
};

int main()
{
	
}
