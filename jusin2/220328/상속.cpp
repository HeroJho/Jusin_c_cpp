#include "pch.h"

#pragma region 상속

// Player Monster ... 겹치는 부분이 많네?
// 똑같은걸 또 만들어야해? >> 상속의 시작

// 기초(base) 클래스     : 데이터를 물려주는 클래스, 부모 클래스 
// 유도(derived) 클래스  : 데이터를 물려받는 클래스, 자식 클래스

class CObj
{

};

// #include "Obj.h"    >> 부모의 헤더 include
class CPlayer : public CObj // 상속
{
    // public 상속만 무조건 사용한다
    // protected private은 있다는 정도만 알기

    // 연속 상속도 가능하다

    // 자식은 부모에 있는 데이터를 자식에서 마음대로 쓸 수 있따.
    // 부모에서는 자식꺼는 절대 못 쓴다(보통의 경우) >> 상속
    // 부모가 자식껄 쓸 수 있다 >> 다형성

    // 상속을 했어도 부모 private은 접근 불가능
    // protected를 하면 자식에서만 접근 가능
};


// 상속은 어떻게 부모 클래스를 알고 쓰는거냐? >> 동작

//*******************생성자, 소멸자 호출 순서 암기!!!! 중요!!!!!!!!!!!!!!!!!!!!
// 생성자 호출
// 메모리 계산 >> 부모 생성자  >>  자식 생성자
// 내부적으로 부모 클래스를 만들어 부모의 멤버, 함수 정보를 가지고 있는다.
// 즉, 객체를 생성할 때마다 각각 다른 부모 멤버, 함수 정보를 가지고 있는 것이다!!!
// 부모라는건 메모리 공간을 공유하는 것이 아니다!!!!!

// 선언된 위치 중심으로 우선권!
// 부모 멤버, 자식 멤버 이름 같다 > 자식 공간에서는 자식 멤버 우선권 갖는다.
// 하지만 사용하고 싶다면 지정 스코프로 부모를 명시하고 사용 ex) CObj::m_iA;

// 소멸자 호출
// 자식 >> 부모 >> 메모리 해제



// 부모 클래스의 생성자 초기화
// 이니셜라이저로 자식 생성자에서 부모 생성자와 연계해서 초기화가 가능
// Player(int _a) : CObj(_a);

#pragma endregion


#pragma region 상속의 조건

// 1. A is-a  B
// 사람-학생-학생회    사람이 전부 학생회냐? 아니다
// 자식이 부모이다    부모는 자식이 아니다
// 사람 >> 학생회 방향은 구체화
// 학생회 >> 사람 방향은 일반화
// 부모는 공통적인것, 자식은 개별적인 것

// 부모에 전부 구현을 하면, 자식에서 자신한테는 필요 없는 기능또한 생성해서 쓸대없는게 된다.
// 필요한 것만 들고 있자라는 것
// is-a 관계일 때만 상속을 사용하자!!

// 2. A  has-a  B
// 예로 Player는 소지 무기가 있어야 공격 가능
// 무기를 소지해야한다
// 다중 상속으로 전부 무기들 상속  Player : public sword, public axe
// 그러면 Player는 무기인가? 뭐하는 놈이야? >> 의미적 문제 발생
// 구조가 엄청 꼬일 수 있다
// 다중 상속은 그냥 쓰지마!!!!!!!!!!!

// 즉, has-a관계를 위해 다중상속은 지양한다.
// 그럼 어떻게 해?
// include로 포함을 해서 사용한다

// is-a는 상속!! has-a는 포함!!


#pragma endregion 

class CA
{
public:
    void PrintA()
    {
        cout << "CA" << endl;
    }
};
class CB : CA
{
public:
    void PrintB()
    {
        cout << "CB" << endl;
    }
};
class CC : CA
{
public:
    void PrintC()
    {
        cout << "CC" << endl;
    }
};

int main()
{
    // 객체 포인터와 상속 관계

    // 컴파일 시점에 어떤걸 호출할 수 있는지 결정 나는 것  >> 정적 바인딩, static 바인딩
    // 선언되어 있는 포인터에 근거해서 어떤 것을 호출할 수 있는 접근 범위를 컴파일 단계에서 알 수 있따는 말이다
    //   >>> 여기 까지가 상속

    // 포인터의 자료형을 기준으로 접근 허용

    return 0;
}