#include <iostream>

#include "Player.h"

using namespace std;

// 클래스 이름 앞에는 C가 들어간다
// 예약 클래스: 언어 자체가 클래스를 제공하는 형태로 제공되고, 이미 만들어진 이름의 클래스가 존재한다.
//	ㄴ이름으로 사용 불가 >> 대부분 고유 명사(CObject)를 피해서 이름을 짓는다

class CObj
{
	// private
	int		m_iA;	// m_   멤버변수라는 의미(헝가리 표기)
	
	// public
public:
	int		A;
	int		B;

public:
	int		C;

private:
	int		D;


protected:
	int		E;

public:
	// access method (접근 함수)
	// 은닉화를 지키는 두 번째 수단!!
	// 즉, 멤버 변수가 생길 때마다 이런 함수가 필요하다!!
	void Set_A(int _iA)		// Set, Get을 붙여서 함수의 목적성을 표기!
	{
		m_iA = _iA;
	}
	int Get_A()
	{
		return m_iA;
	}

	void Render()		// 멤버 함수
	{
		cout << A << endl;		// 내부 접근
	}
};

int main()
{
	// 객체 = 클래스(자료형) + 인스턴스(메모리 상태)

	// 클래스의 4대 속성
	// 은닉화, 캡슐화, 상속성, 다형성 ******암기!!!!
	
	// 은닉화 : 클래스 내의 데이터와 기능를 외부로 부터(클래스 밖) 보호하는(숨기는) 성질을 의미
	// 접근 제어 지시자 : private protected public
	// private		내부접근 허용
	// public		내부, 외부접근 허용
	// protected	>> 자식에게만 public, 그 외에는 private (상속성에서 자세히)

	// 구조체의 default 접근 지정자 >> public
	// 클래스의 default 접근 지정자 >> private

	// 이런 접근 지정자는 원하는 대로 지정할 수 있다


	// 왜 접근 지정자(은닉성)를 사용해??
	//	ㄴ혼자서는 public으로 다 해도 상관없지만, 협업을 할 때는 막 클래스를 다루니 유지보수가 힘들어진다.
	//      ㄴ얘를 쓸거면 이렇게 써! 라는 허들을 일부로 만드는 것이다.
	//          ㄴ규칙이 생긴다는 것!

	{
		CObj	Obj;
		Obj.m_iA = 100;					// 외부 접근
		cout << Obj.m_iA << endl;
	}


	// 이제부터 멤버 변수는 private으로 하는 것!!! 무조건!!	>> 데이터를 보호하고 싶다는 것 !! 중요오오옹!!!!!!!!
	// 함수는 public . 함수는 코드의 재사용 >> 외부의 데이터를 가공하는 것이다. 이걸 제한한다? X 모순!
	// 그 클래스에서만 사용하는거면 private. ex) 플레이어의 키 입력
	{
		// 함수를 통해 private의 멤버 변수에 접근한다!
		// access method

		CObj	obj;
		obj.Set_A(150);	

		cout << obj.Get_A() << endl;
	}




	// 캡슐화

	// 주어만 들어도 그런 기능, 데이터가 있을것이다 유추가 가능한게 캡슐화 
	// 주어와 관련된 것을 묶는 것
	// 캡슐화는 은닉화의 개념이 있어야 성립가능한 개념이다. (알약)
	//	ㄴ캡슐안에 무슨 약들이 있는지 알 수 없지만, 효과가 어떤지는 알 수 있다.
	// 캡슐화된 클래스를 보면 구체적인 기능을 알 수 없다.
	// 캡슐화는 의미만 있고 문법적인 것은 없다..
	//   ㄴ어떤 기능을 캡슐화하고 할 것은 주관적인 것이다. 그래서 어렵다!
	//		ㄴ 좋은 유지보수를 하기 위해서는 캡슐화가 적절히 이뤄줘야 한다.
	
	
	return 0;
}

// 1숙제 : 클래스를 이용해서 성적표 만들기 ( 동적 할당으로 만들기)  >> 학생 수 제한없이 만들기
// 2 : 텍스트 알피지를 클래스로 만들기 >> 저장 불러오기는 필요없음
//    ㄴ h, cpp 분리해서 만들기