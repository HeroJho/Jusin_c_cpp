#include<iostream>
using namespace std;

void main()
{

#pragma region 포인터 원리 문법
	
	// 둘 A는 다른 메모리 공간이다.
	{
		int a = 10;
		cout << a << endl; // 직접적인 접근 (이름을 통한 접근) 스택
	}
	{
		int a = 20;
		cout << a << endl;
	}

	// 코드를 짤 때 주소는 절대주소를 복사한 16진수 주소를 쓴다.
	// 이 복사주소를 사용해서 다른 지역의 메모리 공간을 접근할 수 있게된다. >> 간접 접근: 주소를 통한 접근
	
	// 즉, 메모리에 접근 방법 2가지 직접 접근, 간접 접근!!



	// 포인터 자료형은 메모리 주소를 저장하는 자료형이다
	// 주소값은 { }(지역변수)와 파일범위(전역변수)를 뛰어넘는 범위를 가진다 >> RAM의 주소이니, RAM의 주소는 불변!!
	// 주소값만 알면 어디든지 해당 메모리 공간을 접근할 수 있게된다!!
	// 이 주소값을 저장하는 변수가 '포인터'이다!

	// 포인터는 변수다 >> 흐름에 따라 저장 값이 바뀔 수 있다는 말이다.
	
	// 참조: 주소값을 통해 메모리 공간에 접근하는 행위이다.
	// 1바이트당 하나의 주소값을 가진다. (ex)int 형 변수는 4바이트이기 때문에 주소 값을 네게 가진다.
	// 그 중에 가장 빠른 번지의 주소를 '대표 주소'라고 한다.
	// 포인터는 이 대표 주소를 저장한다.

	

	// 포인터의 선언
	int iA = 0;
	int* p;   // int 포인터형 p(int형 변수의 주소값을 저장하는 용도)

	// 포인터를 0으로 초기화 명시
	int* pp = NULL;      // c   버전
	int* ppp = nullptr;  // c++ 버전 

	// address 연산자: 대표주소를 추출해 주는 연산자
	p = &iA;
	cout << &iA << endl;
	cout << p << endl;

	// p = 10;    10은 int형 >> 자료형이 안 맞아 대입연산 불가능!
	// 포인터 연산자: 포인터가 가진 주소 공간의 값을 가리키는 연산자
	*p = 10;   
	cout << iA << endl;

	int iB = 1;  // 포인터도 변수이기 때문에 코드 라인에 따라서 주소값이 바뀔 수 있다.
	p = &iB;

	cout << *p << endl;

	
#pragma endregion

	// 포인터도 변수이기 때문에 크기가 있다, 또 크기가 존재한다는 것은 그 갯수 만큼 주솟값이 있다는 것이다.

	int* pt = nullptr;
	char* ppt = nullptr;
	double* pppt = nullptr;

	cout << sizeof(pt) << endl;
	cout << sizeof(ppt) << endl;
	cout << sizeof(pppt) << endl;

	// 포인터의 크기는 4바이트로 고정이다
	// 32비트 = 4바이트,  64 = 8바이트 운영체제에 따라 포인터 크기가 다르다
	// 왜?
	// 32비트는 주소가 4바이트 까지 표현이 가능하다. 0xffffffff
	// 그러니 최고 주소를 표현하려면 4바이트까지는 표현이 가능해야 한다.

	
	// 포인터 연산
	char at = 10;
	char* pat = &at;
	cout << pat << endl;
	pat++;  // 주솟값이 이동(char형포인터라면 2바이트 이동해라) 접근까지는 허용. 하지만 사용하려면 에러!
	cout << pat << endl;

	*pat = 99;   // 2바이트만큼 이동한 위치에 99로 변경(불허)
	cout << *pat << endl; // 에러!
	// 선언한다는 것은 = "나 이것 만큼 메모리 사용할게"라고 컴파일러한테 허가를 받는 것
	// 허가를 받지않은 공간에 강제로 접근하려고 해서 >> 메모리 침범!! >> 다른 프로그램이 쓰고 있을 수도 있잖아
	

	// 숙제
	int iA = 10, iB = 20;
	cout << iA << "\n" << iB << endl;
	// ? : 함수와 포인터를 통해 두 숫자를 교환하여 출력하라

	cout << iA << "\n" << iB << endl;
}

