#include <iostream>
using namespace std;

void Swap(int& A, int& B)  // 8바이트 공간이 필요하면 되겠네!
{						   // 컴파일러는 함수를 읽을 때 인자의 이름는 신경 안 쓴다! 크기에만 관심이 있다! 그래서 초기화 안하고 참조 가능!
	int iTemp = 0;
	iTemp = A;
	B = A;
	A = iTemp;
}

void main()
{
#pragma region 래퍼런스

	// c++에서 생긴 문법
	// 변수 이름에 또 다른 이름을 부여하는 문법, 동작은 포인터와 유사하게 동작한다.

	// 왜 사용할까?
	// 포인터는 간접 참조라 쓰기도 어렵고 포인터의 4바이트도 아깝다라는 것
	{
		int iA = 0;    
		int iB = 10;
		int& r = iA;
		r = 100;
		cout << iA << endl;


		// 레퍼런스는 자료형이지 변수가 아니다!
		// 반드시 선언과 동시에 초기화 형태를 만들어줘야 한다.
		r = iB;
		r = 200;
		cout << iB << endl;  

		// 참조하고자 하는 자료형 크기 자체는 필요하니 사이즈는 나오긴 한다.   >>    따로 메모리 공간을 가진다는건 아니다!
		cout << sizeof(int&) << endl; // 4가 나온다          // 상수와 같은 특성이라 초기화한 녀석만 참조한다.
		cout << sizeof(char&) << endl; // 2 나온다
		
		// 포인터는 변수다
		// 래퍼런스 자체는 주소값을 가지지 않는다.
		
		// 주소가 같다!
		cout << &iA << endl;    
		cout << &r << endl;

		// 정리: 레퍼런스는 참조만 하기 위해 탄생한 문법, 상수 형태로 오로지 하나의 데이터만 참조하며, 따로 메모리 공간을 갖지 않는다.

		// 장점: 포인터 보다는 빠르고 용량이 소비되지 않는다. (사실 크게 의미 없다)
		// 단점: 일종의 상수 포인터처럼 동작 원리를 가지고 있다. 오로지 하나의 공간만 참조할 수 있다.


		const int iA = 20;
		// int& r = iA;      // const가 붙은 읽기 전용 변수를 래퍼런스로 참조를 시키면, 값 변경의 가능성이 생기기 때문에 허용하지 않는다.
		const int& r = iA;   // 레퍼런스 또한 const를 붙여 참조는 하되, 일기 전용으로 사용할 수는 있다.

		// int& r2 = 30;     // 리터럴 상수는 임시 메모리 공간에 저장되고 라인을 벗어나면 사라진다. 즉 바로 소멸될 메모리를 참조할 수 없다.
		const int& r2 = 30;  // 임시 변수에다가 리터럴 상수를 저장하고 참조하게 한다 c++에서 허가 했따. 그래도 써서는 안 되는 거임. 그럴일도 없고
	}

#pragma endregion

}
// 수요일 종강 >> 필기도구 필요 